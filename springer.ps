% Authors: Serap Kadam, Christoph Muellner

/n {8} def
/m {8} def
/s {24} def

/chessfield n m mul array def

/chessfield_init { % Set all chessfield elements to -1
	0 1 n m mul 1 sub {chessfield exch -1 put} for
} def

/pos_is_visited { % (position -- true/false)
	chessfield exch get
	-1 ne
} def

/pos_is_oor { % (position -- true/false)
	dup 0 lt
	exch n m mul ge
	or
} def

/drop_invalid_pos { % ( neighbours, calculated position, calculated row, compare row -- neighbours, [calculated position] )
	eq
	{dup pos_is_oor
		{pop 1 sub}		% drop if out of range
		{dup pos_is_visited
			{pop 1 sub}	% drop if visited
			{exch}		% valid
			ifelse
		}
		ifelse
	}
	{pop 1 sub}			% drop if rows not ok
		ifelse
} def

/get_neighbour_1 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup 2 n mul 1 add sub	% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	2 n mul sub n idiv	% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_2 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup 2 n mul 1 sub sub	% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	2 n mul sub n idiv	% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_3 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup n 2 sub sub		% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	n sub n idiv		% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_4 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup n 2 add add		% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	n add n idiv		% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_5 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup 2 n mul 1 add add	% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	2 n mul add n idiv	% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_6 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup 2 n mul 1 sub add	% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	2 n mul add n idiv	% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_7 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup n 2 sub add		% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	n add n idiv		% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbour_8 {
	1 add			% current position, neighbours++
	dup index		% current position, neighbours, current position
	dup n 2 add sub		% current position, neighbours, current position, calculated position
	dup n idiv		% current position, neighbours, current position, calculated position, calculated row
	3 -1 roll		% current position, neighbours, calculated position, calculated row, current position
	n sub n idiv		% current position, neighbours, calculated position, calculated row, compare row
	drop_invalid_pos	% current position, calculated position, neighbours
} def

/get_neighbours {
	0	% neighbours = 0
	get_neighbour_1
	get_neighbour_2
	get_neighbour_3
	get_neighbour_4
	get_neighbour_5
	get_neighbour_6
	get_neighbour_7
	get_neighbour_8
} def

/choose_best_neighbour {
	8 -1 count 2 roll {				% neighbours of best neighbour, best neighbour position, (current pos, neighbour positions,) neighbours
		get_neighbours				% neighbours of best neighbour, best neighbour position, (...) neighbours of current neighbour
		dup count 1 roll {pop} repeat	% current neighbours, neighbours of best neighbour, best neighbour position, (...)
		%count 1 sub index count 2 sub index
		count -2 roll				% best neighbour position, (...) current neighbours, neighbours of best neighbour
		2 copy lt
			{pop count -1 roll pop exch count 2 roll}	% neighbours of new best neighbour, new best neighbour position, (current pos, remaining neighbour positions)
			{count 1 roll pop pop}						% neighbours of old best neighbour, old best neighbour position, (current pos, remaining neighbour positions)
			ifelse
	} repeat

	count -1 roll pop			% best neighbour position, current pos
	count -1 roll				% current pos, best neighbour position
} def

/travel {
	chessfield 2 index 2 index put
} def

/chessfield_print {
	0 1 n m mul 1 sub {chessfield exch get =} for
} def

/main {
	chessfield_init s {
		get_neighbours dup 0 eq {exit} if
		choose_best_neighbour
		travel
	} loop
	pop % Pop zero on top of stack
	pstack % That's the path
	count n m mul eq {(Eine Loesung wurde gefunden) =} {(Keine Loesung wurde gefunden) =} ifelse
} def

/test {
	% Test if there exists a solution for all start points
	0 1 n m mul 1 sub {
		chessfield_init {
			get_neighbours dup 0 eq {exit} if
			choose_best_neighbour
			travel
		} loop
		pop
		count n m mul ne {(Keine Loesung wurde gefunden fuer:) =} if
		count 1 sub {pop} repeat =
	} for
} def

test
